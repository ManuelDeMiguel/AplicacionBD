g.\n   * If a string is passed, the `^` character is prepended and the `$` character is\n   * appended to the provided string (if not already present), and the resulting regular\n   * expression is used to test the values.\n   *\n   * @returns A validator function that returns an error map with the\n   * `pattern` property if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static pattern(pattern: string|RegExp): ValidatorFn {\n    return patternValidator(pattern);\n  }\n\n  /**\n   * @description\n   * Validator that performs no operation.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static nullValidator(control: AbstractControl): ValidationErrors|null {\n    return nullValidator(control);\n  }\n\n  /**\n   * @description\n   * Compose multiple validators into a single function that returns the union\n   * of the individual error maps for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error maps of the validators if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static compose(validators: null): null;\n  static compose(validators: (ValidatorFn|null|undefined)[]): ValidatorFn|null;\n  static compose(validators: (ValidatorFn|null|undefined)[]|null): ValidatorFn|null {\n    return compose(validators);\n  }\n\n  /**\n   * @description\n   * Compose multiple async validators into a single function that returns the union\n   * of the individual error objects for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error objects of the async validators if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static composeAsync(validators: (AsyncValidatorFn|null)[]): AsyncValidatorFn|null {\n    return composeAsync(validators);\n  }\n}\n\n/**\n * Validator that requires the control's value to be greater than or equal to the provided number.\n * See `Validators.min` for additional information.\n */\nexport function minValidator(min: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors|null => {\n    if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {\n      return null;  // don't validate empty values to allow optional controls\n    }\n    const value = parseFloat(control.value);\n    // Controls with NaN values after parsin